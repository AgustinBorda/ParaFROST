\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{url}

%
\newcommand{\parafrost}{ParaFROST\xspace}
\newcommand{\parafrostHRE}{ParaFROST\_HRE\xspace}
\newcommand{\parafrostCBT}{ParaFROST\_CBT\xspace}
\newcommand{\parafrostALL}{ParaFROST\_ALL\xspace}


% mute the stupid IEEEtrans bibtex error!
\makeatletter
\def\endthebibliography{%
	\def\@noitemerr{\@latex@warning{Empty `thebibliography' environment}}%
	\endlist
}
\makeatother

\begin{document}

\title{ParaFROST, ParaFROST\_CBT, ParaFROST\_HRE, ParaFROST\_ALL at the SAT Race 2020
\thanks{This work is part of the GEARS project with project number TOP2.16.044, which is (partly) financed by the Netherlands Organisation for Scientific Research (NWO).}
}

\author{\IEEEauthorblockN{Muhammad Osama and Anton Wijs}
	\IEEEauthorblockA{Department of Mathematics and Computer Science\\
		Eindhoven University of Technology, 5600 MB Eindhoven, The Netherlands\\
	}
}

\maketitle

\section{Introduction}
This paper presents a brief description to our solver \parafrost which stands for \emph{Parallel Formal Reasoning Of SaTisfiability} in 4 different configurations. Our solver is based on state-of-the-art CDCL search~\cite{grasp,minisat,glucose}, integrated with preprocessing as presented in SIGmA (SAT sImplification on GPU Architectures)~\cite{sigmaTacas,sigmaIfm} and a new technique called Parallel Decision Making (PDM)~\cite{pdcl}. However, all submitted versions only allows a single-threaded CPU execution.

\parafrost provides easy-to-use infrastructure for SAT solving and/or preprocessing with optimized data structures for both CPU/GPU architectures, and fine-tuned heuristic parameters. The \emph{Parallel} keyword in \parafrost intuitively means that SAT simplifications can be fully executed on variables in parallel as described in~\cite{sigmaTacas} using the Least Constrained Variable Elections (LCVE) algorithm while periodically, via the PDM procedure~\cite{pdcl}, the solver is capable of making decisions that can be assigned and propagated in parallel as well. Choosing variables to preprocess or decisions relies heavily on \emph{freezing} (that is where FROST originated) mutually independent variables according to some logical properties. 
%
%
\section{Preprocessing}
In previous work, we have shown how Bounded Variable Elimination (BVE) and hybrid subsumption elimination (HSE) can be performed in parallel on Graphics processing Units (GPU) which proven to be effective in increasing the amount of reductions within a fraction of second, e.g. 66$\times$ speedup compared to SatElite when combined together in \texttt{ve+} mode~\cite{sigmaTacas}. This mode iterates over BVE and HSE in several rounds untill no literals can be removed. Moreover, we
have added new implementations for blocked clause elimination (BCE) and a new type
of elimination we call hidden redundancy elimination (HRE)~\cite{sigmaIfm}. HRE repeats the following until a fixpoint has been reached: for a given formula $\mathcal{S}$ and clauses $C_1\in\mathcal{S},C_2\in\mathcal{S}$ with $x\in C_1$ and $\bar{x}\in C_2$ for some variable $x$, if there exists a clause $C\in S$ for which $C\equiv C_1 \otimes_{x} C_2$ and $C$ is not a tautology, then let $\mathcal{S} := \mathcal{S} \setminus \{C\}$. The clause $C$ is called a \emph{hidden redundancy} and can be removed without altering the original satisfiability.
For example, consider the formula $\mathcal{S}=\{\{a,\bar{c}\},\{c,b\},\{\bar{d},\bar{c}\},\{b, a\},\{a,d\}\}$.
Resolving the first two clauses gives the resolvent $\{a,b\}$ which is equivalent to the fourth clause in $\mathcal{S}$. Also, resolving the third clause with the last clause yields $\{a,\bar{c}\}$ which is equivalent to the first clause in $\mathcal{S}$. HRE can remove either $\{a,\bar{c}\}$ or $\{a,b\}$ but not both.

In this submission, a sequential implementation of all simplifications described above is provided as part of \parafrost. By default, in \parafrost, all simplifications are disabled. 
In \parafrostHRE, the \texttt{ve+} is enabled with number of \texttt{phases} set to 2. The \texttt{phases=<n>} option applies \texttt{ve+} for a configured number of iterations, with increasingly large values of the threshold $\mu$ (maximum occurrences of a variable). After all phases are done, the \texttt{HRE} method is executed once. The \parafrostALL configuration enables all simplifications explained above along with \texttt{bce}.

\parafrostHRE and \parafrostALL delay preprocessing by a user-defined number of restarts. This gives the solver enough time to solve trivial problems (solved in few seconds), especially large formulas before simplifications are executed. The number of restarts needed to activate preprocessing is set to 20 through the option \texttt{pre-delay=<n>}. The solver supports geometric~\cite{geoRestart}, Luby~\cite{minisat}, and dynamic restarts~\cite{dynamicRestarts}. However, in this submission, we enable only dynamic restarts.
%
%
\section{Parallel Decision Making}
We proposed a new approach~\cite{pdcl} to make parallel decisions in such a way, they can be assigned and propagated simultaneously without causing any implications or conflicts. Originally, we did so to introduce a possible parallelisation strategy. This strategy is yet to pay off, but surprisingly, the PDM turned out to have
a considerably positive impact on standard, sequential CDCL, for many different SAT benchmark problems. In all configurations, the solver periodically calls PDM with a maximum of 3 rounds per search. Otherwise, a single decision is made as the standard CDCL procedure does. The number of PDM rounds is controlled via the option \texttt{pdm=<n>}. 
%
%
\section{Chronological Backtracking}
We adopted the \emph{chronological backtracking} (CBT) introduced by the authors in~\cite{cbt}, to help CDCL solvers avoid jumping too far in certain situations. However, the procedure is computationally expensive in calculating the correct chronological level during a conflict. Therefore, we enabled this feature in a separate solver instance called \parafrostCBT (all simplifications are disabled). The CBT is triggered when the number of conflicts are multiple of 5000 (\texttt{cbt-conf=<n>}) and the jumping distance is 500 (\texttt{cbt-dist=<n>}). In \parafrostHRE, this option is disabled.
%
%
\section{Automated Tuning}
The GPU code tuner made by Ben van Werkhoven~\cite{tuner,tunerCode} is used to optimize the parameter settings of all heuristics in \parafrostALL. The tool is capable of tuning both CPU and GPU codes with support for many search optimization algorithms. In our case, we collected a sample of 48 different formulas, stemmed from different CNF families. The solving time per problem is expected to take 1000 seconds according to a solver experiment without tuning. Then we ran a Python script to optimize the solver based on the accumulated running time of the selected benchmark suite. The tuned parameters are passed to the solver as command-line options. The basin hopping strategy is used to accelerate the tuning process.

Finally, the solver instance \parafrostALL comprises all configurations described in the previous sections, in which PDM, CBT, and all simplifications are enabled.

%========== references ===========
\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,pf_refs}

\end{document}

\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{url}

%
\newcommand{\parafrost}{ParaFROST\xspace}
\newcommand{\parafrostHRE}{ParaFROST\_HRE\xspace}
\newcommand{\parafrostCBT}{ParaFROST\_CBT\xspace}
\newcommand{\parafrostALL}{ParaFROST\_ALL\xspace}


% mute the stupid IEEEtrans bibtex error!
\makeatletter
\def\endthebibliography{%
	\def\@noitemerr{\@latex@warning{Empty `thebibliography' environment}}%
	\endlist
}
\makeatother

\begin{document}

\title{ParaFROST, ParaFROST\_CBT, ParaFROST\_HRE, ParaFROST\_ALL at the SAT Race 2020
\thanks{This work is part of the GEARS project with project number TOP2.16.044, which is (partly) financed by the Netherlands Organisation for Scientific Research (NWO).}
}

\author{\IEEEauthorblockN{Muhammad Osama and Anton Wijs}
	\IEEEauthorblockA{Department of Mathematics and Computer Science\\
		Eindhoven University of Technology, 5600 MB Eindhoven, The Netherlands\\
	}
}

\maketitle

\section{Introduction}
This paper presents a brief description to our solver \parafrost which stands for \emph{Parallel Formal Reasoning Of SaTisfiability} in 4 different configurations. Our solver is based on state-of-the-art CDCL search~\cite{grasp,minisat,glucose}, integrated with preprocessing as presented in our tool called SIGmA (SAT sImplification on GPU Architectures)~\cite{sigmaTacas,sigmaIfm}, and a new technique called Multiple Decision Making (MDM)~\cite{pdcl}. Nevertheless, all submitted versions only permits a single-threaded CPU execution.

\parafrost provides easy-to-use infrastructure for SAT solving and/or preprocessing with optimized data structures for both CPU/GPU architectures, and fine-tuned heuristic parameters. The \emph{Parallel} keyword in \parafrost intuitively means that SAT simplifications can be fully executed on variables in parallel as described in~\cite{sigmaTacas} using the Least Constrained Variable Elections (LCVE) algorithm. Moreover, via the MDM procedure~\cite{pdcl}, the solver is capable of making multiple decisions that can be assigned and propagated at once. In principle, choosing variables to preprocess or decisions relies heavily on \emph{freezing} (that is where FROST is surfaced) mutually independent variables according to some logical properties. 
%
%
\section{Preprocessing}
In previous work, we have shown how Bounded Variable Elimination (BVE)~\cite{niver,satelite} and Hybrid Subsumption Elimination (HSE) can be performed in parallel on Graphics Processing Units (GPU). The acceleration is proven to be effective in increasing the amount of reductions within a fraction of second, e.g. 66$\times$ speedup compared to SatElite~\cite{satelite} when combined together in \texttt{ve+} mode~\cite{sigmaTacas}. This mode iterates over BVE and HSE in several rounds until no literals can be removed. 
Furthermore, we have added new implementations for Blocked Clause Elimination (BCE) and a new simplification technique, we call Hidden Redundancy Elimination (HRE)~\cite{sigmaIfm}. HRE repeats the following until a fixpoint has been reached: for a given formula $\mathcal{S}$ and clauses $C_1\in\mathcal{S},C_2\in\mathcal{S}$ with $x\in C_1$ and $\bar{x}\in C_2$ for some variable $x$, if there exists a clause $C\in S$ for which $C\equiv C_1 \otimes_{x} C_2$ and $C$ is not a tautology, then let $\mathcal{S} := \mathcal{S} \setminus \{C\}$. The clause $C$ is called a \emph{hidden redundancy} and can be removed without altering the original satisfiability.
For example, consider the formula $\mathcal{S}=\{\{a,\bar{c}\},\{c,b\},\{\bar{d},\bar{c}\},\{b, a\},\{a,d\}\}$.
Resolving the first two clauses gives the resolvent $\{a,b\}$ which is equivalent to the fourth clause in $\mathcal{S}$. Also, resolving the third clause with the last clause yields $\{a,\bar{c}\}$ which is equivalent to the first clause in $\mathcal{S}$. HRE can remove either $\{a,\bar{c}\}$ or $\{a,b\}$ but not both.

In this submission, a sequential implementation of all simplifications described above is provided as part of \parafrost. By default, in \parafrost, all simplifications are disabled. 
In \parafrostHRE, the \texttt{ve+} is enabled with number of \texttt{phases} set to 2. The \texttt{phases=<n>} option applies \texttt{ve+} for a configured number of iterations, with increasingly large values of the threshold $\mu$ (maximum occurrences of a variable)~\cite{sigmaTacas,sigmaIfm}. After all phases are done, the \texttt{hre} method is executed once. On the other hand, the \parafrostALL submission enables all simplifications along with \texttt{bce}.

both \parafrostHRE and \parafrostALL delay preprocessing by a user-defined number of restarts. This gives the solver enough time to solve trivial problems (solved in few seconds) before simplifications are executed. The number of restarts needed to activate preprocessing is set to 50 through the option \texttt{pre-delay=<n>}. The solver supports geometric~\cite{geoRestart}, Luby~\cite{minisat}, and dynamic restarts~\cite{dynamicRestarts}. However, in all submissions, we only enable dynamic restarts.
%
%
\section{Multiple Decision Making}
We proposed a new approach~\cite{pdcl} to make multiple decisions in such a way, they can be assigned and propagated simultaneously or sequentially without causing any implications or conflicts. Originally, we did so to introduce a possible parallelisation strategy. This strategy is yet to pay off, but surprisingly, the MDM turned out to have a positive impact on standard, sequential CDCL, for many different formulas. In all configurations, the solver periodically calls MDM with a maximum of 3 rounds per search. Otherwise, a single decision is made as the standard CDCL procedure does. The number of MDM rounds is controlled via the option \texttt{PDM=<n>}. 
%
%
\section{Chronological Backtracking}
We adopted the \emph{chronological backtracking} (CBT) introduced by the authors in~\cite{cbt}, to help CDCL solvers avoid jumping too far in certain situations. However, the procedure is computationally expensive in calculating the correct chronological level during a conflict. Therefore, we enabled this feature in a separate solver instance called \parafrostCBT (all simplifications are disabled). The CBT is triggered when the number of conflicts are multiple of 5000 (\texttt{cbt-conf=<n>}) and the jumping distance is 500 (\texttt{cbt-dist=<n>}). In \parafrostHRE, this option is disabled.
%
%
\section{Automated Tuning}
The GPU code tuner made by Ben van Werkhoven~\cite{tuner,tunerCode} is used to optimize the parameter settings of all heuristics in \parafrostALL. The tool is capable of tuning both CPU and GPU codes with support for many search optimization algorithms. In our case, we collected a sample of 48 different formulas, stemmed from different CNF families. The solving time per problem is expected to take 1000 seconds according to a solver experiment without tuning. Then, we ran a Python script to optimize the solver based on the accumulated running time of the selected benchmark suite. The tuned parameters are passed to the solver as command-line options. The basin hopping strategy is used to accelerate the tuning process.

Finally, the solver instance \parafrostALL comprises all configurations described in the previous sections, in which HRE, CBT, and all simplifications are enabled.

%========== references ===========
\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,pf_refs}

\end{document}
